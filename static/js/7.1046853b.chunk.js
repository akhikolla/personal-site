(this["webpackJsonppersonal-site"]=this["webpackJsonppersonal-site"]||[]).push([[7],{163:function(n,e,t){"use strict";t.r(e);t(1);var s=t(7),l=t(39),r=t.n(l),a=t(16),i=t(0);const o="## JSON Parse\n\n```\ndef get_value_with_wildcard(data, key_path):\n    keys = key_path.lstrip('.').split('.')\n\n    def helper(current_data, remaining_keys):\n        if not remaining_keys:\n            return [current_data]\n\n        key = remaining_keys[0]\n        rest = remaining_keys[1:]\n        results = []\n\n        # Easy case \u2014 direct key\n        if key != '*':\n            if isinstance(current_data, dict):\n                if key in current_data:\n                    return helper(current_data[key], rest)\n                else:\n            return []  # Key not found or not a dict\n\n        # Wildcard case \u2014 '*' matches all keys at this level\n        else:\n            if isinstance(current_data, dict):\n                for sub_key, sub_val in current_data.items():\n                    results.extend(helper(sub_val, rest))\n\n            return results\n\n    final_results = helper(data, keys)\n\n    if not final_results:\n        return None\n    elif len(final_results) == 1:\n        return final_results[0]\n    else:\n        return final_results\n\n```\n\n### No with \\*\n\n```\ndef get_value_easy(data, key_path):\n\n    keys = key_path.lstrip('.').split('.')\n    current_data = data\n    for key in keys:\n        if isinstance(current_data, dict):\n            if key in current_data:\n                current_data = current_data[key]\n            else:\n                return None\n        else:\n            return None\n\n    return current_data\n\n```\n\n## Valid Parentheses\n\n> [link](https://leetcode.com/problems/valid-parentheses/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        hmap = {\n            ')' : '(',\n            '}' : '{',\n            ']' : '['\n        }\n        q = []\n        for ch in s:\n            if q and ch in hmap.keys() and q[-1] == hmap[ch]:\n                q.pop()\n            else:\n                q.append(ch)\n        return len(q) == 0\n```\n\n## Merge Sorted Array\n\n> [link](https://leetcode.com/problems/merge-sorted-array/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m + n - 1\n\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] >= nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1-=1\n            else:\n                nums1[p] = nums2[p2]\n                p2-=1\n            p-=1\n```\n\n## Merge Intervals\n\n> [link](https://leetcode.com/problems/merge-intervals/description/)\n\n```\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key = lambda i: i[0])\n        merged_intervals = [intervals[0]]\n\n        for start, end in intervals[1:]:\n            prevEnd = merged_intervals[-1][1]\n            if start <= prevEnd:\n                merged_intervals[-1][1] = max(prevEnd, end)\n            else:\n                merged_intervals.append([start,end])\n\n        return merged_intervals\n```\n\n## Best Time to Buy and Sell Stock\n\n> [link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        i = 0\n        j = 0\n        maxProfit = 0\n\n        while j < len(prices):\n            if prices[i] < prices[j]:\n                maxProfit = max(maxProfit, prices[j] - prices[i])\n            else:\n                i = j\n            j+=1\n\n        return maxProfit\n```\n\n## Contains Duplicate\n\n> [link](https://leetcode.com/problems/contains-duplicate/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        # count_dict = {}\n        # for num in nums:\n        #     if num in count_dict:\n        #         return True\n        #     count_dict[num] = 1\n        # return False\n\n        return len(nums) > len(set(nums))\n```\n\n## Contains Duplicate II\n\n> [link](https://leetcode.com/problems/contains-duplicate-ii/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        nums_count = {}\n\n        for i in range(len(nums)):\n            if nums[i] in nums_count:\n                if(abs(nums_count[nums[i]] - i) <= k):\n                    return True\n\n            nums_count[nums[i]] = i\n\n        return False\n\n```\n\n## Summary Ranges\n\n> [link](https://leetcode.com/problems/summary-ranges/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        summary_ranges = []\n        start = 0\n        i = 0\n\n        while i < len(nums):\n            start = nums[i]\n\n            while i + 1 < len(nums) and nums[i] + 1 == nums[i+1]:\n                i+=1\n\n            if start != nums[i]:\n                summary_ranges.append(str(start) + '->' + str(nums[i]))\n            else:\n                summary_ranges.append(str(nums[i]))\n\n            i+=1\n\n        return summary_ranges\n```\n\n## Logger Rate Limiter\n\n> [link](https://leetcode.com/problems/logger-rate-limiter/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Logger:\n\n    def __init__(self):\n        self.msg_dict = {}\n\n    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n        if message not in self.msg_dict:\n            self.msg_dict[message] = timestamp\n            return True\n\n        if timestamp - self.msg_dict[message] >= 10:\n            self.msg_dict[message] = timestamp\n            return True\n        else:\n            return False\n\n\n# Your Logger object will be instantiated and called as such:\n# obj = Logger()\n# param_1 = obj.shouldPrintMessage(timestamp,message)\n```\n\n## Time Based Key-Value Store\n\n> [link](https://leetcode.com/problems/time-based-key-value-store/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass TimeMap:\n\n    def __init__(self):\n        self.timeMap = {}\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.timeMap:\n            self.timeMap[key] = []\n        self.timeMap[key].append([value, timestamp])\n\n\n    def get(self, key: str, timestamp: int) -> str:\n        res = \"\"\n        values = self.timeMap.get(key, [])\n        l , r = 0, len(values) -1\n        while l <= r:\n            mid = (l + r) // 2\n            if values[mid][1] <= timestamp:\n                res = values[mid][0]\n                l = mid + 1\n            else:\n                r = mid - 1\n        return res\n\n\n# Your TimeMap object will be instantiated and called as such:\n# obj = TimeMap()\n# obj.set(key,value,timestamp)\n# param_2 = obj.get(key,timestamp)\n```\n\n## Longest Substring Without Repeating Characters\n\n> [link](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_index = {}\n        start = 0\n        longest_substring = 0\n\n        for r in range(len(s)):\n            if s[r] in char_index and char_index[s[r]] >= start:\n                start = char_index[s[r]] + 1\n            else:\n                longest_substring = max(longest_substring, r - start + 1)\n\n            char_index[s[r]] = r\n\n        return longest_substring\n\n```\n\n## Merge Intervals\n\n> [link](https://leetcode.com/problems/merge-intervals/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key = lambda i: i[0])\n        merged_intervals = [intervals[0]]\n\n        for start, end in intervals[1:]:\n            prevEnd = merged_intervals[-1][1]\n            if start <= prevEnd:\n                merged_intervals[-1][1] = max(prevEnd, end)\n            else:\n                merged_intervals.append([start,end])\n\n        return merged_intervals\n```\n\n## LRU Cache\n\n> [link](https://leetcode.com/problems/lru-cache/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.hash_table = {}\n        self.capacity = capacity\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.total_items = 0\n\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        node = self.hash_table.get(key)\n        if node is None:\n            return -1\n\n        self._move_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        node = self.hash_table.get(key)\n        if node is None:\n            new_node = ListNode(key, value)\n            self.hash_table[key] = new_node\n            self._add_to_head(new_node)\n            self.total_items+=1\n\n            if(self.total_items > self.capacity):\n                self._remove_lru_entry()\n        else:\n            node.value = value\n            self._move_to_head(node)\n\n    def _remove_lru_entry(self):\n        tail_item = self._pop_tail()\n        del self.hash_table[tail_item.key]\n        self.total_items-=1\n\n    def _pop_tail(self) -> ListNode:\n        lru_node = self.tail.prev\n        self._remove_from_list(lru_node)\n        return lru_node\n\n    def _move_to_head(self, node: ListNode):\n        self._remove_from_list(node)\n        self._add_to_head(node)\n\n    def _add_to_head(self, node: ListNode):\n        node.prev = self.head\n        node.next = self.head.next\n\n        self.head.next.prev = node\n        self.head.next = node\n\n    def _remove_from_list(self, node: ListNode):\n        saved_prev = node.prev\n        saved_next = node.next\n\n        saved_prev.next = saved_next\n        saved_next.prev = saved_prev\n\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n### Alternate approach\n\n```\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = self.next= None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = {}\n        self.capacity = capacity\n        self.lru_ptr = self.mru_ptr = ListNode()\n\n        self.lru_ptr.next = self.mru_ptr\n        self.mru_ptr.prev = self.lru_ptr\n\n    def remove(self, node):\n        prev, next = node.prev, node.next\n        prev.next, next.prev = next, prev\n\n    def insert(self, node):\n        prev, next = self.mru_ptr.prev, self.mru_ptr\n        prev.next = next.prev = node\n        node.prev, node.next = prev, next\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = ListNode(key, value)\n        self.insert(self.cache[key])\n\n        if(len(self.cache) > self.capacity):\n            lru = self.lru_ptr.next\n            self.remove(lru)\n            del self.cache[lru.key]\n\n\n\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n## Word Search\n\n> [link](https://leetcode.com/problems/word-search/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n        visited = set()\n\n        def dfs(row, col, i):\n            if i == len(word):\n                return True\n\n            if(row < 0 or col < 0\n            or row >= ROWS or col >= COLS\n            or word[i] != board[row][col]\n            or (row,col) in visited):\n                return False\n\n            visited.add((row,col))\n            res = (dfs(row+1, col, i+1) or\n                dfs(row-1, col, i+1) or\n                dfs(row, col+1, i+1) or\n                dfs(row, col-1, i+1))\n\n            visited.remove((row,col))\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if(dfs(r, c, 0)):\n                    return True\n        return False\n\n```\n\n## Insert Delete GetRandom O(1)\n\n> [link](https://leetcode.com/problems/insert-delete-getrandom-o1/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass RandomizedSet:\n\n    def __init__(self):\n        self.nmap = {}\n        self.nlist = []\n\n    def insert(self, val: int) -> bool:\n        res = val not in self.nmap\n        if res:\n            self.nmap[val] = len(self.nlist)\n            self.nlist.append(val)\n        return res\n\n    def remove(self, val: int) -> bool:\n        res = val in self.nmap\n        if res:\n            index = self.nmap[val]\n            lastVal = self.nlist[-1]\n\n            self.nlist[index] = lastVal\n            self.nlist.pop()\n\n            self.nmap[lastVal] = index\n            del self.nmap[val]\n        return res\n\n    def getRandom(self) -> int:\n       return random.choice(self.nlist)\n\n\n# Your RandomizedSet object will be instantiated and called as such:\n# obj = RandomizedSet()\n# param_1 = obj.insert(val)\n# param_2 = obj.remove(val)\n# param_3 = obj.getRandom()\n```\n\n## Rotate Array\n\n> [link](https://leetcode.com/problems/rotate-array/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        start = 0\n        end = len(nums) - 1\n\n        def swapElements(l , r):\n            while(l < r):\n                temp = nums[l]\n                nums[l] = nums[r]\n                nums[r] = temp\n                l+=1\n                r-=1\n\n        swapElements(start, end)\n        swapElements(start, k-1)\n        swapElements(k, end)\n```\n\n## Coin Change\n\n> [link](https://leetcode.com/problems/coin-change/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount+1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1+dp[a-c])\n\n        return dp[amount] if dp[amount] != amount + 1 else -1\n\n```\n\n## Top K Frequent Elements\n\n> [link](https://leetcode.com/problems/top-k-frequent-elements/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count_elements = {}\n\n        for num in nums:\n            count_elements[num] = count_elements.get(num, 0) + 1\n\n        freq = [[] for _ in range(len(nums) + 1)]\n        for num, c in count_elements.items():\n            freq[c].append(num)\n\n        result = []\n        for i in range(len(freq)-1, 0, -1):\n            result.extend(freq[i])\n            if len(result) >= k:\n                return result[:k]\n```\n\n## Top K Frequent Words\n\n> [link](https://leetcode.com/problems/top-k-frequent-words/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        most_frequent_words = {}\n\n        for s in words:\n            most_frequent_words[s] = most_frequent_words.get(s, 0) + 1\n\n        freq = [[] for _ in range(len(words) + 1)]\n\n        for s, c in most_frequent_words.items():\n            freq[c].append(s)\n            freq[c].sort()\n\n        result = []\n        for f in range(len(freq)-1, 0, -1):\n            result.extend(freq[f])\n            if(len(result) >= k):\n                return result[:k]\n```\n\n## Daily Temperatures\n\n> [link](https://leetcode.com/problems/daily-temperatures/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def dailyTemperatures(self, l: List[int]) -> List[int]:\n        stack = []\n        nextGreaterTemparatures = [0] * len(l)\n\n        for i in range(len(l)):\n            while stack and l[stack[-1]] < l[i]:\n                nextGreaterTemparatures[stack[-1]] = i - stack[-1]\n                stack.pop()\n\n            stack.append(i)\n        return nextGreaterTemparatures\n```\n\n## Generate Parentheses\n\n> [link](https://leetcode.com/problems/generate-parentheses/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        valid_parentheses = []\n\n        def generateParenthesis(open_count, close_count, cur):\n            if len(cur) == 2*n:\n                valid_parentheses.append(cur)\n                return cur\n\n            if open_count < n:\n                generateParenthesis(open_count+1, close_count, cur + '(')\n\n            if close_count < open_count :\n                generateParenthesis(open_count, close_count + 1, cur + ')')\n\n        generateParenthesis(0,0, '')\n        return valid_parentheses\n```\n\n## Implement Queue using Stacks\n\n> [link](https://leetcode.com/problems/implement-queue-using-stacks/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x: int) -> None:\n        self.s1.append(x)\n\n\n    def pop(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2.pop()\n\n\n    def peek(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2[-1]\n\n    def empty(self) -> bool:\n        return max(len(self.s1), len(self.s2)) == 0\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### Python Syntax:\n\n#### Lists\n\n```\narr = []\narr = list()\n\narr.append(x)\narr.pop()\narr.pop(i)\narr.insert(i, x)\narr.remove(x)\nx in arr\n\narr.sort() #In place sort, O(nlogn)\nsorted(arr) #returns sorted list O(nlogn)\narr.reverse() # In place reverse\n```\n\n#### Dictionary(HashMap)\n\n```\nd = {}\nd = dict()\n\nd[key] = value\nd.get(key, default) # get with default if the key is missing, O(1)\ndel d[key] # delete key value pair\nkey in d\nd.keys() # get keys view\nd.values() # get values view\nd.items()  # get key value pairs view\nd.pop(key) # remove and return the value\n```\n\n#### Set(HashSet)\n\n```\ns = set()\ns = {1,2,3}\n\ns.add(x)\ns.remove(x)\ns.discard(x)\nx in s\ns1 | s2 # Union\ns1 & s2 # Intersection\ns1 - s2 # difference\n```\n\n#### Queue\n\n```\nfrom collections import deque\n\nq = deque()\n\nq.append(x) // add to right\nq.appendLeft(x) // add to left\nq.pop() // pops right element\nq.popLeft() // pops left element\n```\n\n#### Stack\n\n```\nstack = []\nstack.append(x)\nstack.pop()\nstack[-1] // peeks top element in stack\n```\n\n#### Heap\n\n```\nimport heapq\n\nheap = []\nheapq.heapify(list) // converts list to heap\n\nheapq.heappush(heap, x) // add element O(log n)\nheapq.heappop(heap) // remove and return smallest O(log n)\nheap[0] // peek smallest O(1)\nheapq.nlargest(k, heap) # Get k largest elements O(nlogk)\nheapq.nsmallest(k, heap) # Get k smallest elements O(nlogk)\n\n// for max queue negate values when pushing or popping\n\n```\n\n#### LinkedList\n\n```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nhead = ListNode(1)\nhead.next = ListNode(2)\ntemp = head.next\nhead.next = temp.next\n```\n\n#### Tree\n\n```\nclass TreeNode:\n    def __init(self, val=0, left=None, right=None):\n        self.val = val\n        self.right = right\n        self.left = left\n\n// Binary search tree operations average O(logn), worst O(n)\n```\n\n#### Graphs\n\n```\n// Adjacency list\n\ngraph = defaultdict(list)\ngraph = {0 : [1,2], 1:[2], 2: []}\n\ngraph = [[0,1,1], [0,0,1], [0,0,0]]\n```\n\n#### Trie\n\n```\nclass TrieNode:\n    def __init__(self):\n        self.children = []\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word:str) -> None: O(m), m words\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n```\n\n#### Common Built-in functions\n\n```\n# Sorting\nsorted(iterable)\nreversed(iterable)\n\nmin(iterable)\nmax(iterable)\n\nsum(iterable)\n\n[x for x in range(10)] // create list from expression\n\ns.split() // splits string into list\n''.join(list) // join list elements into string\n\n```\n",d=(o.split(/\s+/).map((n=>n.replace(/\W/g,""))).filter((n=>n.length)).length,n=>{let{...e}=n;return Object(i.jsx)(s.b,{...e})});e.default=()=>Object(i.jsx)(a.a,{title:"Blog",description:"Learn about Blind75",fullPage:!0,children:Object(i.jsxs)("article",{className:"post markdown",id:"blog",children:[Object(i.jsx)("header",{children:Object(i.jsx)("div",{className:"title",children:Object(i.jsx)("h2",{"data-testid":"heading",children:Object(i.jsx)(s.b,{to:"/Blog",children:"Learn"})})})}),Object(i.jsx)("h2",{style:{color:"green"},children:Object(i.jsx)("li",{children:Object(i.jsx)(s.b,{to:"/SystemDesign",children:"SystemDesign"})})}),Object(i.jsx)("br",{}),Object(i.jsx)(r.a,{source:o,renderers:{Link:d},escapeHtml:!1})]})})}}]);
//# sourceMappingURL=7.1046853b.chunk.js.map