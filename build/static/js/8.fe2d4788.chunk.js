(this["webpackJsonppersonal-site"]=this["webpackJsonppersonal-site"]||[]).push([[8],{163:function(n,e,t){"use strict";t.r(e);t(1);var s=t(5),l=t(69),i=t.n(l),a=t(18),r=t(0);const o="### Practice Logic\n\n## Valid Parentheses\n\n$${\\color{blue}[link](https://leetcode.com/problems/valid-parentheses/?envType=company&envId=netflix&favoriteSlug=netflix-all)}$$\n\n```\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        hmap = {\n            ')' : '(',\n            '}' : '{',\n            ']' : '['\n        }\n        q = []\n        for ch in s:\n            if q and ch in hmap.keys() and q[-1] == hmap[ch]:\n                q.pop()\n            else:\n                q.append(ch)\n        return len(q) == 0\n```\n\n## Merge Sorted Array\n\n:link:[link](https://leetcode.com/problems/merge-sorted-array/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m + n - 1\n\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] >= nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1-=1\n            else:\n                nums1[p] = nums2[p2]\n                p2-=1\n            p-=1\n```\n\n## Best Time to Buy and Sell Stock\n\n[link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        i = 0\n        j = 0\n        maxProfit = 0\n\n        while j < len(prices):\n            if prices[i] < prices[j]:\n                maxProfit = max(maxProfit, prices[j] - prices[i])\n            else:\n                i = j\n            j+=1\n\n        return maxProfit\n```\n\n## Contains Duplicate\n\n[link](https://leetcode.com/problems/contains-duplicate/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        # count_dict = {}\n        # for num in nums:\n        #     if num in count_dict:\n        #         return True\n        #     count_dict[num] = 1\n        # return False\n\n        return len(nums) > len(set(nums))\n```\n\n## Contains Duplicate II\n\n[link](https://leetcode.com/problems/contains-duplicate-ii/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        nums_count = {}\n\n        for i in range(len(nums)):\n            if nums[i] in nums_count:\n                if(abs(nums_count[nums[i]] - i) <= k):\n                    return True\n\n            nums_count[nums[i]] = i\n\n        return False\n\n```\n\n## Summary Ranges\n\n[link](https://leetcode.com/problems/summary-ranges/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        summary_ranges = []\n        start = 0\n        i = 0\n\n        while i < len(nums):\n            start = nums[i]\n\n            while i + 1 < len(nums) and nums[i] + 1 == nums[i+1]:\n                i+=1\n\n            if start != nums[i]:\n                summary_ranges.append(str(start) + '->' + str(nums[i]))\n            else:\n                summary_ranges.append(str(nums[i]))\n\n            i+=1\n\n        return summary_ranges\n```\n\n## Logger Rate Limiter\n\n[link](https://leetcode.com/problems/logger-rate-limiter/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Logger:\n\n    def __init__(self):\n        self.msg_dict = {}\n\n    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n        if message not in self.msg_dict:\n            self.msg_dict[message] = timestamp\n            return True\n\n        if timestamp - self.msg_dict[message] >= 10:\n            self.msg_dict[message] = timestamp\n            return True\n        else:\n            return False\n\n\n# Your Logger object will be instantiated and called as such:\n# obj = Logger()\n# param_1 = obj.shouldPrintMessage(timestamp,message)\n```\n\n## Longest Substring Without Repeating Characters\n\n[link](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_index = {}\n        start = 0\n        longest_substring = 0\n\n        for r in range(len(s)):\n            if s[r] in char_index and char_index[s[r]] >= start:\n                start = char_index[s[r]] + 1\n            else:\n                longest_substring = max(longest_substring, r - start + 1)\n\n            char_index[s[r]] = r\n\n        return longest_substring\n\n```\n\n## Merge Intervals\n\n[link](https://leetcode.com/problems/merge-intervals/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key = lambda i: i[0])\n        merged_intervals = [intervals[0]]\n\n        for start, end in intervals[1:]:\n            prevEnd = merged_intervals[-1][1]\n            if start <= prevEnd:\n                merged_intervals[-1][1] = max(prevEnd, end)\n            else:\n                merged_intervals.append([start,end])\n\n        return merged_intervals\n```\n\n## LRU Cache\n\n[link](https://leetcode.com/problems/lru-cache/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.hash_table = {}\n        self.capacity = capacity\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.total_items = 0\n\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        node = self.hash_table.get(key)\n        if node is None:\n            return -1\n\n        self._move_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        node = self.hash_table.get(key)\n        if node is None:\n            new_node = ListNode(key, value)\n            self.hash_table[key] = new_node\n            self._add_to_head(new_node)\n            self.total_items+=1\n\n            if(self.total_items > self.capacity):\n                self._remove_lru_entry()\n        else:\n            node.value = value\n            self._move_to_head(node)\n\n    def _remove_lru_entry(self):\n        tail_item = self._pop_tail()\n        del self.hash_table[tail_item.key]\n        self.total_items-=1\n\n    def _pop_tail(self) -> ListNode:\n        lru_node = self.tail.prev\n        self._remove_from_list(lru_node)\n        return lru_node\n\n    def _move_to_head(self, node: ListNode):\n        self._remove_from_list(node)\n        self._add_to_head(node)\n\n    def _add_to_head(self, node: ListNode):\n        node.prev = self.head\n        node.next = self.head.next\n\n        self.head.next.prev = node\n        self.head.next = node\n\n    def _remove_from_list(self, node: ListNode):\n        saved_prev = node.prev\n        saved_next = node.next\n\n        saved_prev.next = saved_next\n        saved_next.prev = saved_prev\n\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n## Rotate Array\n\n[link](https://leetcode.com/problems/rotate-array/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        start = 0\n        end = len(nums) - 1\n\n        def swapElements(l , r):\n            while(l < r):\n                temp = nums[l]\n                nums[l] = nums[r]\n                nums[r] = temp\n                l+=1\n                r-=1\n\n        swapElements(start, end)\n        swapElements(start, k-1)\n        swapElements(k, end)\n```\n\n## Coin Change\n\n[link](https://leetcode.com/problems/coin-change/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount+1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1+dp[a-c])\n\n        return dp[amount] if dp[amount] != amount + 1 else -1\n\n```\n\n## Top K Frequent Elements\n\n[link](https://leetcode.com/problems/top-k-frequent-elements/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count_elements = {}\n\n        for num in nums:\n            count_elements[num] = count_elements.get(num, 0) + 1\n\n        freq = [[] for _ in range(len(nums) + 1)]\n        for num, c in count_elements.items():\n            freq[c].append(num)\n\n        result = []\n        for i in range(len(freq)-1, 0, -1):\n            result.extend(freq[i])\n            if len(result) >= k:\n                return result[:k]\n```\n\n## Top K Frequent Words\n\nU+1F51x7[link](https://leetcode.com/problems/top-k-frequent-words/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n\n```\nclass Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        most_frequent_words = {}\n\n        for s in words:\n            most_frequent_words[s] = most_frequent_words.get(s, 0) + 1\n\n        freq = [[] for _ in range(len(words) + 1)]\n\n        for s, c in most_frequent_words.items():\n            freq[c].append(s)\n            freq[c].sort()\n\n        result = []\n        for f in range(len(freq)-1, 0, -1):\n            result.extend(freq[f])\n            if(len(result) >= k):\n                return result[:k]\n```\n\n## Daily Temperatures\n\n<span style=\"color:blue\">[link](https://leetcode.com/problems/daily-temperatures/description/?envType=company&envId=netflix&favoriteSlug=netflix-all)\n</span>\n\n```\nclass Solution:\n    def dailyTemperatures(self, l: List[int]) -> List[int]:\n        stack = []\n        nextGreaterTemparatures = [0] * len(l)\n\n        for i in range(len(l)):\n            while stack and l[stack[-1]] < l[i]:\n                nextGreaterTemparatures[stack[-1]] = i - stack[-1]\n                stack.pop()\n\n            stack.append(i)\n        return nextGreaterTemparatures\n```\n",d=(o.split(/\s+/).map((n=>n.replace(/\W/g,""))).filter((n=>n.length)).length,n=>{let{...e}=n;return Object(r.jsx)(s.b,{...e})});e.default=()=>Object(r.jsx)(a.a,{title:"Blog",description:"Learn about Blind75",fullPage:!0,children:Object(r.jsxs)("article",{className:"post markdown",id:"blog",children:[Object(r.jsx)("header",{children:Object(r.jsx)("div",{className:"title",children:Object(r.jsx)("h2",{"data-testid":"heading",children:Object(r.jsx)(s.b,{to:"/Blog",children:"Blind75"})})})}),Object(r.jsx)(i.a,{source:o,renderers:{Link:d},escapeHtml:!1})]})})}}]);
//# sourceMappingURL=8.fe2d4788.chunk.js.map